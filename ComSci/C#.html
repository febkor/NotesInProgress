<!DOCTYPE html><html lang=en><head><meta http-equiv=content-type content="text/html; charset=UTF-8"><meta name=viewport content="width=device-width, initial-scale=1"><title>C# | Notes in Progress</title><meta name=robots content=noindex><meta property=og:title content=C#><meta property=og:site_name content=Notes in progress><meta property=og:type content=article><script type=application/ld+json>
  {"@type":"BlogPosting","headline":"Notes in Progress","dateModified":"2019-02-09T00:00:00+00:00","datePublished":"2019-02-09T00:00:00+00:00","url":https://febkor.github.io/NotesInProgress,"mainEntityOfPage":{"@type":"WebPage","@id":https://febkor.github.io/NotesInProgress},"description":"Notes","@context":"http://schema.org"}</script><link rel=stylesheet href=https://febkor.github.io/NotesInProgress/static/main.css><link rel="shortcut icon" type=image/x-icon href=https://febkor.github.io/NotesInProgress/static/favicon.ico><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script></head><body><header class=site-header role=banner><div class=wrapper><a class=site-title rel=author href=https://febkor.github.io/NotesInProgress>Notes in Progress</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger><label for=nav-trigger></label></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><article class="post h-entry" itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class="post-title p-name" itemprop="name headline">C#</h1></header><div class="post-content e-content" itemprop=articleBody><h1 id=methods>Methods</h1><ul><li><code>virtual</code>: have an implementation and provide the derived classes with the option of overriding it.</li><li><code>abstract</code>: do not provide an implementation and force the derived classes to override the method.</li><li><code>override</code>: overrides the method in the base class (can specify <code>sealed</code> to prevent further overriding)</li><li><code>new</code>: the method in the derived class hides the one in the base class</li></ul><h2 id=cast>Cast</h2><ul><li><code>T s = (T)o</code>; Use when something should definitely be the other thing (throws InvalidCastException if not).</li><li><code>T s = o as T</code>; Use when something might be the other thing (assigns null if not).</li></ul><h1 id=async>Async</h1><p>If a method is declared async make sure there is an await.</p><p>Async method shouldn&#x2019;t return <code>void</code>, return <code>Task</code> if nothing to return. Reasons:</p><ul><li>Exceptions thrown in an async void method can&#x2019;t be caught outside of that method, since the exception is captured and placed on the Task object.</li><li>async void methods can cause side effects if the caller isn&#x2019;t expecting them to be async (like?)</li><li>difficult to test</li></ul><p>Consider using return Task instead of return await:</p><div class=sourceCode id=cb1><pre class="sourceCode csharp"><code class="sourceCode cs"><span id=cb1-1><a href=#cb1-1></a><span class=kw>public</span> async Task&lt;<span class=dt>string</span>&gt; <span class=fu>AsyncTask</span>()</span>
<span id=cb1-2><a href=#cb1-2></a>{</span>
<span id=cb1-3><a href=#cb1-3></a>    <span class=co>// non-async stuff</span></span>
<span id=cb1-4><a href=#cb1-4></a>    <span class=kw>return</span> await <span class=fu>GetData</span>();</span>
<span id=cb1-5><a href=#cb1-5></a>}</span>
<span id=cb1-6><a href=#cb1-6></a></span>
<span id=cb1-7><a href=#cb1-7></a><span class=kw>public</span> Task&lt;<span class=dt>string</span>&gt; <span class=fu>JustTask</span>()</span>
<span id=cb1-8><a href=#cb1-8></a>{</span>
<span id=cb1-9><a href=#cb1-9></a>    <span class=co>// non-async stuff</span></span>
<span id=cb1-10><a href=#cb1-10></a>    <span class=kw>return</span> <span class=fu>GetData</span>();</span>
<span id=cb1-11><a href=#cb1-11></a>}</span></code></pre></div><p>This avoids the generation of the (somewhat expensive) async state machine. However, do not wrap <code>return Task</code> inside <code>try-catch</code> or <code>using</code> block as an exception thrown by the async method will never be caught, because the task will be returned right away.</p><p>Adding <code>async</code> to function declaration automatically wraps the return with task [check]. Use <code>await</code> to wait for a task to complete, and get the unwrapped result. e.g.&#xA0;<code>await Task.Run(() =&gt; DoStuff())</code>;</p><p>Use <code>.GetAwaiter().GetResult()</code> instead of <code>.Wait()</code> or <code>.Result</code>: simplifies error-handling as the latter will return an AggregateException.</p><p>Async library methods should consider using <code>Task.ConfigureAwait(false)</code> to boost performance. Synchronization context represents a way to return to the original context of the code: whenever a Task is awaited, it captures current (thread) synchronization context before awaiting, but this is usually not needed when writing library code. When <code>Task.ConfigureAwait(false)</code> is used, the code, if possible, avoids this context switch and tries to complete in the thread that completed the task.</p><h2 id=working-with-nulls>Working with nulls</h2><h3 id=coalescing>Coalescing</h3><div class=sourceCode id=cb2><pre class="sourceCode csharp"><code class="sourceCode cs"><span id=cb2-1><a href=#cb2-1></a><span class=co>// Null-coalescing operator </span></span>
<span id=cb2-2><a href=#cb2-2></a><span class=dt>var</span> x = p ?? valueIfNull;</span>
<span id=cb2-3><a href=#cb2-3></a><span class=dt>var</span> x = p ?? <span class=kw>throw</span> <span class=kw>new</span> <span class=fu>ArgumentNullException</span>();</span>
<span id=cb2-4><a href=#cb2-4></a></span>
<span id=cb2-5><a href=#cb2-5></a><span class=co>// Null-conditional operators</span></span>
<span id=cb2-6><a href=#cb2-6></a><span class=dt>var</span> x = p?.<span class=fu>k</span>; <span class=co>// x will be null if p is null</span></span>
<span id=cb2-7><a href=#cb2-7></a><span class=dt>var</span> x = p?[k];</span></code></pre></div><h3 id=equality>Equality</h3><div class=sourceCode id=cb3><pre class="sourceCode csharp"><code class="sourceCode cs"><span id=cb3-1><a href=#cb3-1></a>(x == <span class=kw>null</span>); <span class=co>// `==` can be overloaded</span></span>
<span id=cb3-2><a href=#cb3-2></a>(x <span class=kw>is</span> <span class=kw>null</span>);</span></code></pre></div><p>Newer Roslyn compilers make the behavior of the two operators the same when there is no overloaded equality operator.</p><h1 id=tests>Tests</h1><h2 id=nunit>NUnit</h2><div class=sourceCode id=cb4><pre class="sourceCode csharp"><code class="sourceCode cs"><span id=cb4-1><a href=#cb4-1></a>[Test]</span>
<span id=cb4-2><a href=#cb4-2></a>[<span class=fu>TestCase</span>(<span class=dv>6</span>, <span class=dv>13</span>)]</span>
<span id=cb4-3><a href=#cb4-3></a>[<span class=fu>TestCase</span>(<span class=dv>3</span>, <span class=dv>10</span>)]</span></code></pre></div><h1 id=advanced-features>Advanced Features</h1><h2 id=source-generators>Source Generators</h2><p>A dynamic templating engine that produces C# source code at compile-time. Provides access to the syntax tree which enables compile-time access to information about the code such as members of a class, names and types of members etc. Can provide compile-time reflection which can allow much higher performance including ahead-of-time compilation and linking support.</p><h1 id=references>References</h1><p>https://medium.com/<span class=citation data-cites=deep_blue_day/long-story-short-async-await-best-practices-in-net-1f39d7d84050>@deep_blue_day/long-story-short-async-await-best-practices-in-net-1f39d7d84050</span></p></article></div></main><footer class="site-footer h-card"><data href=/ class=u-url></data><div class=wrapper><h2 class=footer-heading>Notes in Progress</h2><div class=footer-col-wrapper><div class="footer-col footer-col-1"><ul class=contact-list><li class=p-name>febkor</li></ul></div></div></div></div></footer></body></html>