<!DOCTYPE html><html lang=en><head><meta http-equiv=content-type content="text/html; charset=UTF-8"><meta name=viewport content="width=device-width, initial-scale=1"><title>Assembly | Notes in Progress</title><meta name=robots content=noindex><meta property=og:title content=Assembly><meta property=og:site_name content=Notes in progress><meta property=og:type content=article><script type=application/ld+json>
  {"@type":"BlogPosting","headline":"Notes in Progress","dateModified":"2019-02-09T00:00:00+00:00","datePublished":"2019-02-09T00:00:00+00:00","url":https://febkor.github.io/NotesInProgress,"mainEntityOfPage":{"@type":"WebPage","@id":https://febkor.github.io/NotesInProgress},"description":"Notes","@context":"http://schema.org"}</script><link rel=stylesheet href=https://febkor.github.io/NotesInProgress/static/main.css><link rel="shortcut icon" type=image/x-icon href=https://febkor.github.io/NotesInProgress/static/favicon.ico><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script></head><body><header class=site-header role=banner><div class=wrapper><a class=site-title rel=author href=https://febkor.github.io/NotesInProgress>Notes in Progress</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger><label for=nav-trigger></label></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><article class="post h-entry" itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class="post-title p-name" itemprop="name headline">Assembly</h1></header><div class="post-content e-content" itemprop=articleBody><h1 id=arm>ARM</h1><p>The ARM architecture is a load-store architecture, with a 32-bit addressing range (64-bit is also available). ARM processors are typical of RISC processors in that only load and store instructions can access memory. Data processing instructions operate on register contents only.</p><h2 id=instruction-cycle>Instruction Cycle</h2><ul><li>fetch: fetch instruction from memory at PC (program counter) address</li><li>decode</li><li>execute: read values from registers, compute using ALU, write back to register</li></ul><p>If we have 32-bit instructions, then</p><ul><li>PC: address of instruction being fetched</li><li>PC <span class="math inline">-</span> 4: address of instruction being decoded</li><li>PC <span class="math inline">-</span> 8: address of instruction being executed</li></ul><h2 id=registers>Registers</h2><p>Register set/file consists of 16 registers.</p><ul><li>R0&#x2013;R12: store variables <ul><li>R0&#x2013;R3: also used for procedure calls <ul><li>R0: argument / return value / temp value</li><li>R1&#x2013;R3: argument / temp values</li></ul></li><li>R4&#x2013;R11: saved variables</li><li>R12: temp value</li></ul></li><li>R13&#x2013;R15: special purpose <ul><li>R13 (SP): stack pointer</li><li>R14 (LR): link register</li><li>R15 (PC): program counter</li></ul></li></ul><h2 id=immediates>Immediates</h2><p>Aka constants. Don&#x2019;t require register or memory access. Are unsigned 12-bit (range 0&#x2013;4095) numbers.</p><p>Examples</p><ul><li>decimal: <code>#24</code>, <code>#-5</code></li><li>hex: <code>#0x18</code></li><li>binary: <code>#11000</code></li></ul><h2 id=instructions>Instructions</h2><pre><code>; comment</code></pre><p><code>Op Rd, S1, S2</code></p><p>Mnemonic/operation destination-operand, source-operand1, source-operand2</p><h3 id=operations>Operations</h3><ul><li>Arithmetic <ul><li><code>ADD</code>: <code>r1 = r2 + r3</code></li><li><code>ADC</code>: <code>r1 = r2 + r3 + C</code></li><li><code>SUB</code>: <code>r1 = r2 - r3</code></li><li><code>SUBC</code>: <code>r1 = r2 - r3 + C - 1</code></li><li><code>RSB</code>: <code>r1 = r3 - r2</code></li><li><code>RSC</code>: <code>r1 = r3 - r2 + C - 1</code></li></ul></li><li>Logical (bitwise) <ul><li><code>AND</code></li><li><code>ORR</code></li><li><code>EOR</code></li><li><code>BIC</code>: bit clear (used for masking), <code>BIC rd, r1, r2</code><span class="math inline">\implies</span><code>rd = r1 and not(r2)</code></li><li><code>MVN</code>: move not, <code>MVN rd, rs</code><span class="math inline">\implies</span><code>rd = not(rs)</code></li></ul></li><li>Shifts <ul><li><code>LSL</code>: logical shift left</li><li><code>LSR</code>: logical shift right (shift 0s into msb)</li><li><code>ASR</code>: arithmetic shift right (shift sign-bit into msb)</li><li><code>ROR</code>: rotate right</li></ul></li></ul><p>Some architectures provide:</p><ul><li>Multiplication <ul><li><code>MUL</code>: <code>R1 = R2 * R3</code><ul><li>the least significant 32 bits go in <code>R1</code></li><li>the most significant 32 bits are discarded</li></ul></li><li><code>MULS</code>: will set the N and Z flags</li><li><code>SMULL</code>, <code>UMULL</code><ul><li>(64 &lt;= 32 x 32)</li><li>e.g.&#xA0;<code>UMULL R1, R2, R3, R4</code></li><li>the least significant 32 bits go in <code>R1</code></li><li>the most significant 32 bits go in <code>R2</code></li></ul></li><li><code>SMUL</code>: (32 &lt;= 16 x 16) [no UMUL]</li></ul></li><li>Multiply-Accumulate (MAC) <ul><li><code>MLA</code></li><li><code>MLAS</code>: will set the N and Z flags</li><li><code>SMLA</code>: signed MAC (32 &lt;= 32 + 16 x 16)</li><li><code>SMLAL</code>, <code>UMLAL</code>: (64 &lt;= 64 + 32 x 32)</li></ul></li><li>Division: <code>Rd = S1 / S2</code><ul><li><code>SDIV</code></li><li><code>UDIV</code></li><li>Any bits after the binary point are truncated</li></ul></li></ul><h3 id=conditionals>Conditionals</h3><p>Flags: the top 4 bits of current program status register (CPSR)</p><ul><li>N: negative</li><li>Z: zero</li><li>C: carry</li><li>V: overflow</li></ul><p>If an instruction mnemonic is followed by <code>s</code> (e.g.<code>ADDS</code>), then the N, Z conditional flags will be set. Only some instructions (like <code>CMP</code>, <code>ADDS</code>, <code>SUBS</code>) will set the C, V flags.</p><p>Comparison instructions</p><ul><li><code>CMP</code>: compare, <code>CMP R0, R1</code> sets flags based on <code>R0 - R1</code></li><li><code>CMN</code>: compare negative, <code>CMN R0, R1</code> sets flags based on <code>R0 + R1</code></li><li><code>TST</code>: test, <code>TST R0, R1</code> sets flags based on <code>R0 and R1</code></li><li><code>TEQ</code>: test equivalence, <code>TEQ R0, R1</code> sets flags based on <code>R0 xor R1</code></li></ul><p>If an instruction mnemonic is followed by a condition code (e.g.<code>ADDEQ</code>), then the instruction is executed based on the flags.</p><p>Conditional mnemonics</p><ul><li><code>EQ</code>: equal</li><li><code>NE</code>: not equal</li><li><code>CS</code>: carry set</li><li><code>CC</code>: no carry</li><li><code>MI</code>: negative</li><li><code>PL</code>: non-negative</li><li><code>VS</code>: overflow</li><li><code>VC</code>: no overflow</li><li><code>HS</code>: unsigned <span class="math inline">\geq</span> (same as <code>CS</code>)</li><li><code>LO</code>: unsigned <span class="math inline">&lt;</span> (same as <code>CC</code>)</li><li><code>HI</code>: unsigned <span class="math inline">&gt;</span></li><li><code>LS</code>: unsigned <span class="math inline">\leq</span></li><li><code>GE</code>: signed <span class="math inline">\geq</span></li><li><code>LT</code>: signed <span class="math inline">&lt;</span></li><li><code>GT</code>: signed <span class="math inline">&gt;</span></li><li><code>LE</code>: signed <span class="math inline">\leq</span></li></ul><h3 id=branching>Branching</h3><p>For non-branching instructions, <code>PC</code> increments by 4 after each instruction. After a branch instruction, <code>PC</code> is changed to contain the address of the next instruction to process.</p><ul><li><p>B</p></li><li><p>BL</p></li><li><p>take a label</p></li><li><p>can be un/conditional</p></li></ul><p>If performance is a priority, try avoid branches. Successive branch instructions are especially inefficient.</p><h3 id=memory>Memory</h3><ul><li>Byte-addressable: each byte has an address.</li><li>So each 32-bit word address is a multiple of 4.</li><li>Typically uses little-endian (byte-numbering)</li></ul><p>Operations</p><ul><li><code>LDR</code>: load register, loads word into register <ul><li><code>LDR Rd, [Rbase, offset]</code></li></ul></li><li><code>STR</code>: store register, stores word into memory <ul><li><code>STR Rd, [Rbase, offset]</code></li></ul></li><li><code>LDRB</code>, <code>STRB</code>: load, store a byte</li><li><code>LDRH</code>, <code>STRH</code>: load, store a halfword</li><li><code>LDRSB</code>: load a signed byte</li><li><code>LDRSH</code>: load a signed halfword</li><li><code>LDM</code>, <code>STM</code>: load, store multiple words</li></ul><p>Definitions</p><ul><li>Rbase: base register, stores the base address</li><li>offset: optional offset</li></ul><p>Barrel shifter</p><p>The shift operations can be applied to <code>S2</code> as part of another instruction.</p><p>The barrel shifter can be used to simplify indexing operations:</p><pre class=arm><code>LSL R2, R1, #2   ; the index/offset, which is a multiple of 4 (bytes)
STR R3, [R0, R2] ; R0 = array, R2 = index, R3 = value to store

; the above can be simplified to
STR R3, [R0, R1, LSL #2]</code></pre><p>ARM indexing modes</p><ul><li>offset <ul><li>address = base + offset</li><li><code>LDR R0, [R1, R2]</code></li></ul></li><li>pre-index <ul><li>address = base + offset; base = address</li><li><code>LDR R0, [R1, R2]!</code></li></ul></li><li>post-indexed <ul><li>address = base; base += offset</li><li><code>LDR R0, [R1], R2</code></li></ul></li></ul><p>Directives</p><p><code>DCB</code> sets data in memory and returns the address.</p><div class=sourceCode id=cb3><pre class="sourceCode asm"><code class="sourceCode fasm"><span id=cb3-1><a href=#cb3-1></a>mydata  DCB<span class=bn> 0x0, 0x1, 0x2, 0x3, 0x4</span></span>
<span id=cb3-2><a href=#cb3-2></a>        LDR R0, =mydata</span></code></pre></div><h3 id=functions>Functions</h3><p>Aka procedures, subroutines. Take in arguments and output a return value.</p><p>The calling convention is a scheme for the caller and the callee to agree on where to put the args and the return value.</p><ul><li>Arguments <ul><li>the caller places up to four args in registers R0&#x2013;-R3 before making the function call</li><li>both functions thus know where to find the args and return value, even if the caller and callee were written by different people.</li><li>The callee must not interfere with the behavior of the caller.</li><li>i.e.&#xA0;the callee must know where to return to after it completes, and it must not trample on any saved registers (R4&#x2013;R11, and <code>LR</code>) or memory needed by the caller</li><li>When a function with more than four args is called, the additional input args are placed on the stack (to avoid affecting the values saved in the registers by the caller).</li></ul></li><li>Call <ul><li>use the branch and link instruction (<code>BL</code>) to call a function. <code>BL</code> performs two tasks: <ul><li>it stores the address of the next instruction (the instruction after <code>BL</code>) in the link register (<code>LR</code>)</li><li>it branches to the target instruction</li></ul></li></ul></li><li>Function <ul><li>At the beginning of the function we temporarily store the registers in a part of memory, called the stack, and before we return we simply restore the register values from the stack.</li><li>This allows us to use the registers <code>R4</code>-<code>R11</code></li></ul></li><li>Return <ul><li>the callee places the return value in register R0</li><li>the <code>LR</code> is moved to the <code>PC</code>: <code>MOV PC, LR</code></li><li>Branch indirect (<code>BX</code>), branches to an address contained in a register: <code>MOV PC, LR</code> is then simply <code>BX LR</code></li></ul></li></ul><p>The stack</p><ul><li>The stack is memory that is used to save information within a function</li><li>Each function may allocate stack space to store local variables but must deallocate it before returning</li><li>The stack can expand (uses more memory) or contract as variables are added or removed</li><li>The stack is a last-in-first-out (LIFO) queue <ul><li>The last item pushed onto the stack is the first one that can be popped off</li></ul></li><li>The top of the stack is the most recently allocated space</li><li>The stack pointer, SP (<code>R13</code>), is just a register that points to (i.e.&#xA0;stores the memory address of) the top of the stack</li><li>It starts at a high memory address and decrements to expand as needed</li></ul><h2 id=pseudo-instructions>Pseudo-instructions</h2><h3 id=loading-literals>Loading Literals</h3><p>Allows for loading 32-bit constants (from the literal pool in the text segment). Can also load the address of a labelled variable or pointer in the program.</p><pre class=arm><code>LDR Rd, =literal
LDR Rd, =label</code></pre><p>The assembler places the constant/label in a literal pool and generates a PC-relative LDR instruction that reads the constant from the literal pool e.g.&#xA0;<code>LDR R1, [PC, #0x2A]</code></p><h3 id=nop>NOP</h3><p>Used to achive a delay or to memory-align instructions. Translated to <code>MOV R0, RO</code>.</p><h2 id=exceptions>Exceptions</h2><p>An unscheduled function call that branches to a new address. Can be caused by hardware or software. - Hardware exception triggered by I/O is called an interrupt. - Reading non-existent memory The program then branches to code in the OS.</p><ul><li>An exception is like a function, as it must <ul><li>save the return address and jump to some address</li><li>do its work and clean up</li><li>return back to the program</li></ul></li><li>Exceptions use a vector table to determine where to jump in the exception handler</li><li>They use banked registers (saved program status registers &#x2013; SPSRs) to maintain copies of key registers to avoid corrupting the registers used by the main program</li><li>Exceptions change the program&#x2019;s privilege level, so that the exception handler can access protected memory</li></ul><h2 id=saturated-arithmetic-instructions>Saturated Arithmetic Instructions</h2><p><code>QADD, QDADD, QDSUB, QSUB</code></p><p>When overflow happens, the result is fixed at the most positive or most negative number. ARM has a Q flag to indicate whether overflow or saturation has occurred.</p><h2 id=memory-map>Memory Map</h2><p>The memory address space is divided into:</p><ul><li>a segment for the operating system (OS) and input/output (I/O).</li><li>dynamic data segment <ul><li>holds the stack and the heap</li></ul></li><li>global data segment <ul><li>stores global variables</li><li>aka read/write (RW) segment</li></ul></li><li>the text segment <ul><li>stores the machine code program</li><li>may store literals, read-only data</li><li>aka read-only (RO) segment</li></ul></li><li>exception handlers segment</li></ul><p>In detail:</p><ul><li>Global variables: can be accessed by all functions in a program. They are allocated prior to program execution, and are typically accessed using a static base register (SB = R9) that points to the start of the global data segment.</li><li>Stack: upon start-up the OS sets the stack pointer (SP) to point to the top of the stack. The stack includes temporary storage and local variables, such as arrays, that do not fit in the registers. Functions also use the stack to save and restore registers.</li><li>Heap: stores data that is allocated by the program during runtime</li></ul><h2 id=structured-programming>Structured programming</h2><h3 id=if-statement>If Statement</h3><div class=sourceCode id=cb5><pre class="sourceCode c"><code class="sourceCode c"><span id=cb5-1><a href=#cb5-1></a><span class=cf>if</span> (R0 == R1)</span>
<span id=cb5-2><a href=#cb5-2></a>    <span class=co>// do if</span></span>
<span id=cb5-3><a href=#cb5-3></a><span class=co>// end if</span></span></code></pre></div><pre class=arm><code>    CMP R0, R1
    BNE DONE
    ; do if
DONE</code></pre><h3 id=if-else-statement>If-else Statement</h3><div class=sourceCode id=cb7><pre class="sourceCode c"><code class="sourceCode c"><span id=cb7-1><a href=#cb7-1></a><span class=cf>if</span> (R0 == R1)</span>
<span id=cb7-2><a href=#cb7-2></a>    <span class=co>// do if</span></span>
<span id=cb7-3><a href=#cb7-3></a><span class=cf>else</span></span>
<span id=cb7-4><a href=#cb7-4></a>    <span class=co>// do else</span></span>
<span id=cb7-5><a href=#cb7-5></a><span class=co>// end if</span></span></code></pre></div><pre class=arm><code>    CMP R0, R1
    BNE ELSE
    ; do if
    B DONE
ELSE
    ; do else
DONE </code></pre><h3 id=switch-statement>Switch Statement</h3><div class=sourceCode id=cb9><pre class="sourceCode c"><code class="sourceCode c"><span id=cb9-1><a href=#cb9-1></a><span class=cf>switch</span> (R0)</span>
<span id=cb9-2><a href=#cb9-2></a>    <span class=cf>case</span> R1:</span>
<span id=cb9-3><a href=#cb9-3></a>        <span class=co>// do R1 case</span></span>
<span id=cb9-4><a href=#cb9-4></a>        <span class=cf>break</span>;</span>
<span id=cb9-5><a href=#cb9-5></a>    <span class=cf>case</span> R2:</span>
<span id=cb9-6><a href=#cb9-6></a>        <span class=co>// do R2 case</span></span>
<span id=cb9-7><a href=#cb9-7></a>        <span class=cf>break</span>;</span>
<span id=cb9-8><a href=#cb9-8></a>    <span class=cf>default</span>:</span>
<span id=cb9-9><a href=#cb9-9></a>        <span class=co>// do default</span></span></code></pre></div><pre class=arm><code>CASE1
    CMP R0, R1
    BNE CASE2
    ; do R1 case
    B DONE
CASE2
    CMP R0, R2
    BNE DEFAULT
    ; do R2 case
    B DONE
DEFAULT
    ; do default
DONE</code></pre><h3 id=while-loops>While Loops</h3><div class=sourceCode id=cb11><pre class="sourceCode c"><code class="sourceCode c"><span id=cb11-1><a href=#cb11-1></a><span class=cf>while</span> (R0 == R1)</span>
<span id=cb11-2><a href=#cb11-2></a>    <span class=co>// do while</span></span></code></pre></div><pre class=arm><code>WHILE
    CMP R0, R1
    BNE DONE
    ; do while
    B WHILE
DONE</code></pre><h3 id=do-while-loops>Do-while Loops</h3><div class=sourceCode id=cb13><pre class="sourceCode c"><code class="sourceCode c"><span id=cb13-1><a href=#cb13-1></a><span class=cf>do</span> {</span>
<span id=cb13-2><a href=#cb13-2></a>    <span class=co>// do dowhile</span></span>
<span id=cb13-3><a href=#cb13-3></a>} <span class=cf>while</span> (R0 == R1)</span></code></pre></div><pre class=arm><code>DOWHILE
    ; do dowhile
    CMP R0, R1
    BEQ DOWHILE
DONE</code></pre><h3 id=for-loops>For Loops</h3><div class=sourceCode id=cb15><pre class="sourceCode c"><code class="sourceCode c"><span id=cb15-1><a href=#cb15-1></a><span class=cf>for</span> (<span class=dt>int</span> R0 = <span class=dv>0</span>; RO &lt; R1; R0++)</span>
<span id=cb15-2><a href=#cb15-2></a>    <span class=co>// do for</span></span></code></pre></div><pre class=arm><code>MOV R0, #0
FOR
    CMP R0, R1
    BGE DONE
    ; do for
    ADD R0, R0, #1
    B FOR
DONE</code></pre><h3 id=arrays-and-indexing>Arrays and Indexing</h3><div class=sourceCode id=cb17><pre class="sourceCode c"><code class="sourceCode c"><span id=cb17-1><a href=#cb17-1></a><span class=dt>int</span> array[] = {<span class=dv>0</span>, <span class=dv>1</span>, <span class=dv>2</span>};</span></code></pre></div><pre class=arm><code>MOV R0, #0x10000 ; the base address for array (e.g.)
MOV R1, #0
STR R1, [R0, #0]
MOV R1, #1
STR R1, [R0, #4]
MOV R1, #2
STR R1, [R0, #8]</code></pre><h3 id=function-call>Function call</h3><div class=sourceCode id=cb19><pre class="sourceCode c"><code class="sourceCode c"><span id=cb19-1><a href=#cb19-1></a>    <span class=co>// ...</span></span>
<span id=cb19-2><a href=#cb19-2></a>    <span class=dt>int</span> y = <span class=dv>3</span>;</span>
<span id=cb19-3><a href=#cb19-3></a>    <span class=dt>int</span> z = <span class=dt>double</span>(y);</span>
<span id=cb19-4><a href=#cb19-4></a>    <span class=co>// ...</span></span>
<span id=cb19-5><a href=#cb19-5></a></span>
<span id=cb19-6><a href=#cb19-6></a><span class=dt>int</span> <span class=dt>double</span>(<span class=dt>int</span> x){</span>
<span id=cb19-7><a href=#cb19-7></a>    <span class=cf>return</span> <span class=dv>2</span> * x;</span>
<span id=cb19-8><a href=#cb19-8></a>}</span></code></pre></div><pre class=arm><code>    MOV R0, #3
    BL DOUBLE


DOUBLE
    ADD R0, R0, R0 ; i.e. 2 * R0
    MOV PC, LR</code></pre><h1 id=arm-thumb>ARM Thumb</h1><p>Thumb instructions are 16 bits long. This allows for</p><ul><li>higher code density <ul><li>reduce size, cost of code storage</li><li>reduce power consumption (less code fetched)</li></ul></li><li>higher perf on 16-bit systems</li></ul><p>But this comes at the expense of:</p><ul><li>lacking conditional execution</li><li>supporting shorter immediates</li><li>accessing only the bottom 8 registers</li><li>reusing register as src and dest</li><li>always write status flags</li></ul></article></div></main><footer class="site-footer h-card"><data href=/ class=u-url></data><div class=wrapper><h2 class=footer-heading>Notes in Progress</h2><div class=footer-col-wrapper><div class="footer-col footer-col-1"><ul class=contact-list><li class=p-name>febkor</li></ul></div></div></div></div></footer></body></html>