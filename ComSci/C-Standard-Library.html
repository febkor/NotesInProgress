<!DOCTYPE html><html lang=en><meta http-equiv=content-type content="text/html; charset=UTF-8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width, initial-scale=1"><title>C Standard Library | Notes in Progress</title><meta property=og:title content=C standard library><meta name=description content=PageSubTitle><meta property=og:site_name content=Notes in progress><meta property=og:type content=article><script type=application/ld+json>
  {"@type":"BlogPosting","headline":"C Standard Library","dateModified":"2019-02-09T00:00:00+00:00","datePublished":"2019-02-09T00:00:00+00:00","url":PageUrl,"mainEntityOfPage":{"@type":"WebPage","@id":PageUrl},"description":"PageSubTitle","@context":"http://schema.org"}</script><link rel=stylesheet href=https://febkor.github.io/NotesInProgress/static/main.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){for(var i,t=document.getElementsByClassName("math"),n=0;n<t.length;n++)i=t[n].firstChild,t[n].tagName=="SPAN"&&katex.render(i.data,t[n],{displayMode:t[n].classList.contains("display"),throwOnError:!1})})</script><header class=site-header role=banner><div class=wrapper><a class=site-title rel=author href=https://febkor.github.io/NotesInProgress/ >Notes in Progress</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger> <label for=nav-trigger></label></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><article class="post h-entry" itemscope="" itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class="post-title p-name" itemprop="name headline">C Standard Library</h1></header><div class="post-content e-content" itemprop=articleBody><h1 id=header-files>Header files</h1><ul><li><code>&lt;assert.h></code>: for adding diagnostics that aid program debugging.<li><code>&lt;ctype.h></code>: for functions that test characters for certain properties, and function prototypes for functions that can be used to convert lowercase letters to uppercase letters and vice versa.<ul><li><code>islower()</code><li><code>toupper()</code></ul><li><code>&lt;errno.h></code>: for reporting error conditions.<li><code>&lt;float.h></code>: Contains the floating point size limits of the system.<li><code>&lt;limits.h></code>: Contains the integral size limits of the system.<li><code>&lt;locale.h></code>: enables a program to be modified for the current locale. This enables the computer system to handle different conventions for expressing data like dates, times, money and large numbers throughout the world.<li><code>&lt;math.h></code><li><code>&lt;setjmp.h></code>: for functions that allow by passing of the usual function call and return sequence.<li><code>&lt;signal.h></code>: handle various conditions that may arise during program execution.<li><code>&lt;stdarg.h></code>: for dealing with a list of arguments to a function whose number and types are unknown.<li><code>&lt;stddef.h></code>: Contains common definitions of types used by C for performing certain calculations.<li><code>&lt;stdio.h></code><li><code>&lt;stdlib.h></code>: for conversions of numbers to text and text to numbers, memory allocation, random numbers, and other utility functions.<li><code>&lt;string.h></code>: for string processing functions.<li><code>&lt;time.h></code>: and types for manipulating the time and date.</ul><h2 id=dynamic-memory-allocation>Dynamic memory allocation</h2><p>Both the following functions are contained in <code>stdlib.h</code>.<ul><li><code>void* malloc(int nrOfBytes)</code><ul><li>allocates memory during execution time<li>returns a generic pointer that points to the address of the first memory position in the block<li>returns a <code>NULL</code> pointer if it was unable to allocate the memory<li>eg <code>type* newptr = malloc (arraySize * sizeof( int ));</code><ul><li>allocates memory for an array of integers<li>the array’s starting address is stored in <code>newptr</code></ul></ul><li><code>void free(ptrType* pointerToMemory)</code><ul><li>frees memory allocated previously<li>always free dynamically allocated memory (prevents memory leaks)</ul><li>example usage:<ul><li><code>int* myIntAddress = malloc(sizeof(int));</code><li><code>free(myIntAddress)</code></ul><li>you can draw parallels with this and filehandling<ul><li><code>FILE* filePtr = fopen("abc.xyz","r");</code><li><code>fclose(filePtr);</code></ul></ul><h2 id=io-library-functions>IO library functions</h2><ul><li><code>printf</code><li><code>scanf</code><li>printing/reading variables<ul><li><code>%d</code>: decimal integer<li><code>%f</code>: float, double (<code>printf</code>)<li><code>%e</code>: float, in scientific notation<li><code>%lf</code>: double (<code>scanf</code>)<li><code>%c</code>: char<li><code>%s</code>: string<li><code>%4d</code>: field width (left-pads with up to 4 spaces)<li><code>%-4d</code>: field width (right-pads with up to 4 spaces)<li><code>%.4f</code>: precision (print up to 4 decimal places)</ul><li>common escape sequences<ul><li><code>\n</code>: Newline. Position the cursor at the beginning of the next line.<li><code>\t</code>: Horizontal tab. Move the cursor to the next tab stop.<li><code>\a</code>: Alert. Sound the system bell.<li><code>\\</code>: Backslash. Insert a backslash character in a string.<li><code>\"</code>: Double quote. Insert a double quote character in a string.<li><code>\’</code>: Single quote. Insert a single quote into string.<li><code>\r</code>: Position the cursor at the beginning of the current line.<li><code>\?</code>: Insert a question mark character<li><code>%%</code>: Percentage symbol</ul></ul><h2 id=math-library-functions>Math library functions</h2><p>All of the <code>math.h</code> functions return type <code>double</code>.<ul><li><code>sqrt(x)</code><li><code>exp(x)</code><li><code>log(x)</code>: natural logarithm<li><code>log10(x)</code><li><code>fabs(x)</code>: absolute value of <code>x</code><li><code>ceil(x)</code>: rounds <code>x</code> to the smallest integer greater than <code>x</code><li><code>floor(x)</code>: rounds <code>x</code> to the largest integer less than <code>x</code><li><code>pow(x, y)</code>: <code>x</code> raised to power <code>y</code><li><code>fmod(x, y)</code>: remainder of <code>x/y</code> as a floating point number<li><code>sin(x)</code>: where <code>x</code> is in radians (all trig functions)<li><code>cos(x)</code><li><code>tan(x)</code></ul><h3 id=generating-random-numbers>Generating random numbers</h3><ul><li>from <code>stdlib.h</code><li><code>int rand(void)</code> returns a random integer from <code>0</code> to <code>RAND_MAX = 32767</code><li>e.g. <code>i = 2 + rand() % 5;</code> is a pseudorandom number from 2 to 6 (<span class="math inline">= 5+2-1</span>).<li>computers generally can’t give truly random values; typically a function with an initial value, called a seed, is used to generate numbers that look and behave like random variables (pseudorandm numbers).<li><code>rand()</code> generates the same sequence of numbers for the same seed<li>can use <code>srand()</code> to change the seed value:</ul>
<div class=sourceCode id=cb1><pre class="sourceCode c"><code class="sourceCode c"><a class=sourceLine id=cb1-1 title=1><span class=co>// to set the seed manually</span></a>
<a class=sourceLine id=cb1-2 title=2><span class=dt>unsigned</span> <span class=dt>int</span> seed = <span class=dv>42</span>; <span class=co>// unsigned implies non-negative</span></a>
<a class=sourceLine id=cb1-3 title=3>srand(seed);</a>
<a class=sourceLine id=cb1-4 title=4></a>
<a class=sourceLine id=cb1-5 title=5><span class=co>// to set the seed automatically</span></a>
<a class=sourceLine id=cb1-6 title=6>srand( time( NULL) ); <span class=co>// need &lt;time.h></span></a>
<a class=sourceLine id=cb1-7 title=7></a>
<a class=sourceLine id=cb1-8 title=8><span class=co>// to generate random numbers</span></a>
<a class=sourceLine id=cb1-9 title=9>fprintf(<span class=st>"%d"</span>, rand());</a></code></pre></div><h2 id=file-handling>File handling</h2><h3 id=data-files>Data files</h3><ul><li>Can be created, updated, and processed by C programs.<li>Are used for permanent storage of large amounts of data. Storage of data in variables and arrays is only temporary.<li>Binary files:<ul><li>Unformatted (stored as “raw bytes”)<li>Data not human readable<li>Written and read sequentially or randomly</ul><li>Text files:<ul><li>Data is stored as characters (char)<li>Usually only written and read sequentially</ul></ul><h3 id=opening-and-closing-files>Opening and closing files</h3><p>Opening files
<div class=sourceCode id=cb2><pre class="sourceCode c"><code class="sourceCode c"><a class=sourceLine id=cb2-1 title=1><span class=pp>#include </span><span class=im>&lt;stdio.h></span></a>
<a class=sourceLine id=cb2-2 title=2></a>
<a class=sourceLine id=cb2-3 title=3><span class=dt>FILE</span> * filePtr;</a>
<a class=sourceLine id=cb2-4 title=4>filePtr = fopen( <span class=st>"someFilename.xyz"</span>, <span class=st>"r"</span> );</a>
<a class=sourceLine id=cb2-5 title=5><span class=co>// optional: check if file was opened</span></a>
<a class=sourceLine id=cb2-6 title=6><span class=cf>if</span> ( filePtr == NULL ) {</a>
<a class=sourceLine id=cb2-7 title=7>    printf( <span class=st>"ERROR - file could not be opened!</span><span class=sc>\n</span><span class=st>"</span> );</a>
<a class=sourceLine id=cb2-8 title=8>}</a>
<a class=sourceLine id=cb2-9 title=9><span class=cf>else</span>{</a>
<a class=sourceLine id=cb2-10 title=10>    <span class=co>// do stuff with the file</span></a>
<a class=sourceLine id=cb2-11 title=11>    fclose( filePtr );</a>
<a class=sourceLine id=cb2-12 title=12>} </a></code></pre></div><ul><li>Declares pointer <code>filePtr</code> that may point to a file.<li>Opens <code>someFilename.xyz</code> and let <code>filePtr</code> points to its beginning.<li><code>"r"</code>: File is opened to read and as text file<li>Files should always be closed after use</ul><p>File open modes<ul><li><code>r</code>: Open a file for reading.<li><code>w</code>: Create a file for writing. If the file already exists, empty it.<li><code>a</code>: Append; open/create a file for writing at end of file.<li>update mode:<ul><li><code>r+</code>: Open a file for update (read/write).<li><code>w+</code>: Create a file for update (read/write). If the file already exists, empty it.<li><code>a+</code>: Append; open/create a file for update; writing is done at the end of the file.</ul><li>binary mode:<ul><li><code>rb</code>: Open a file for reading in binary mode.<li><code>wb</code>: Create a file for writing in binary mode. If the file already exists, empty it.<li><code>ab</code>: Append; open/create a file for writing at end of file in binary mode.</ul><li>update, binary:<ul><li><code>rb+</code>: Open a file for update (read/write) in binary mode.<li><code>wb+</code>: Create a file for update in binary mode. If the file already exists, empty it.<li><code>ab+</code>: Append; open/create a file for update in binary mode; writing is done at the end of the file</ul></ul><p>Files and Streams<ul><li>C views each file as a sequence of bytes<li>File ends with the end-of-file marker or file ends at a specified byte<li>Stream created when a file is opened<li>A stream is a communication channel between files and programs<li>Opening a file returns a pointer to a <code>FILE</code> structure<li>Three files with associated streams are automatically opened with program execution:<ul><li>stdin: standard input (keyboard) (in <code>stdio.h</code>)<li>stdout: standard output (screen) (in <code>stdio.h</code>)<li>stderr: standard error (screen)</ul><li><code>FILE</code> structure<ul><li>File descriptor<ul><li>Index into an operating system array, the open file table</ul><li>File Control Block (FCB)<ul><li>Found in every array element, system uses it to administer the file</ul></ul></ul><p>Standard library functions (in <code>stdio.h</code>)<ul><li><code>int fgetc( FILE *stream );</code><ul><li>Reads one character from a file<li>Takes a <code>FILE</code> pointer as an argument<li><code>fgetc( stdin )</code> equivalent to <code>getchar()</code></ul><li><code>int fputc( int char, FILE *stream );</code><li><code>char* fgets( char *str, int count, FILE *stream );</code><ul><li>Reads a line from a file</ul><li><code>int fputs(const char *str, FILE *stream)</code>;<br><li><code>int fscanf( FILE *stream, const char *format, ... );</code><ul><li>File processing equivalents of scanf()</ul><li><code>int fprintf( FILE *stream, const char *format, ... );</code><ul><li>File processing equivalent of printf()</ul><li><code>int feof( FILE *stream );</code><ul><li>Returns true if end-of-file indicator (no more data to process) is set for the specified file</ul><li><code>void rewind( FILE *stream )</code>;<ul><li>Resets the file position pointer to the beginning of the file</ul></ul><p>Example:
<div class=sourceCode id=cb3><pre class="sourceCode c"><code class="sourceCode c"><a class=sourceLine id=cb3-1 title=1><span class=pp>#include </span><span class=im>&lt;stdio.h></span></a>
<a class=sourceLine id=cb3-2 title=2><span class=pp>#include </span><span class=im>&lt;stdlib.h></span></a>
<a class=sourceLine id=cb3-3 title=3></a>
<a class=sourceLine id=cb3-4 title=4><span class=dt>int</span> main () {</a>
<a class=sourceLine id=cb3-5 title=5>   <span class=dt>char</span> str1[<span class=dv>10</span>], str2[<span class=dv>10</span>], str3[<span class=dv>10</span>];</a>
<a class=sourceLine id=cb3-6 title=6>   <span class=dt>int</span> year;</a>
<a class=sourceLine id=cb3-7 title=7>   <span class=dt>FILE</span> * fp;</a>
<a class=sourceLine id=cb3-8 title=8></a>
<a class=sourceLine id=cb3-9 title=9>   fp = fopen (<span class=st>"file.txt"</span>, <span class=st>"w+"</span>);</a>
<a class=sourceLine id=cb3-10 title=10>   fputs(<span class=st>"We are in 2018"</span>, fp);</a>
<a class=sourceLine id=cb3-11 title=11>   </a>
<a class=sourceLine id=cb3-12 title=12>   rewind(fp);</a>
<a class=sourceLine id=cb3-13 title=13>   fscanf(fp, <span class=st>"%s %s %s %d"</span>, str1, str2, str3, &amp;year);</a>
<a class=sourceLine id=cb3-14 title=14>   </a>
<a class=sourceLine id=cb3-15 title=15>   <span class=co>// str1 = "We"</span></a>
<a class=sourceLine id=cb3-16 title=16>   <span class=co>// str2 = "are"</span></a>
<a class=sourceLine id=cb3-17 title=17>   <span class=co>// str3 = "in"</span></a>
<a class=sourceLine id=cb3-18 title=18>   <span class=co>// year = "2018"</span></a>
<a class=sourceLine id=cb3-19 title=19></a>
<a class=sourceLine id=cb3-20 title=20>   fclose(fp);</a>
<a class=sourceLine id=cb3-21 title=21>   </a>
<a class=sourceLine id=cb3-22 title=22>   <span class=cf>return</span>(<span class=dv>0</span>);</a>
<a class=sourceLine id=cb3-23 title=23>}</a></code></pre></div><h3 id=write-toread-from-binary-files>Write to/Read from Binary Files</h3><ul><li><code>fwrite</code>: Transfer bytes from a location in memory to a file<li><code>fread</code>: Transfer bytes from a file to a location in memory</ul><p>Eg: <code>fwrite( &amp;myObj, sizeof( egType ), 1, fPtr );</code><ul><li><code>&amp;myObj</code>: Location to transfer bytes from<li><code>sizeof( egType )</code>: Number of bytes to transfer<li><code>1</code>: For arrays, number of elements to transfer. In the eg, only one element is being transferred<li><code>fPtr</code>: File to transfer to or from</ul><h3 id=random-access-files>Random-Access Files</h3><ul><li>Access individual records without searching through other records<li>Instant access to records in a file<li>Data can be inserted without destroying other data<li>Data previously stored can be updated or deleted without overwriting<li>Implemented using fixed-length records<ul><li>i.e. some data is set aside for each record<li>Text files usually do not have fixed-length records and are therefore handled sequentially (not like the pc can know how long each line will be).</ul><li>Data in random-access files<ul><li>Random-access files are usually binary/unformatted (stored as “raw bytes”)<li>All data of the same type (eg ints) use the same amount of space as in memory<li>All records of the same type have a fixed length<li>Data is not human readable</ul></ul><h3 id=writing-data-to-a-random-access-file>Writing Data to a Random-Access File</h3><p>Sets file position pointer to a specific position
<div class=sourceCode id=cb4><pre class="sourceCode c"><code class="sourceCode c"><a class=sourceLine id=cb4-1 title=1><span class=dt>int</span> fseek( <span class=dt>FILE</span> *stream, <span class=dt>long</span> <span class=dt>int</span> offset, <span class=dt>int</span> whence );</a>
<a class=sourceLine id=cb4-2 title=2></a>
<a class=sourceLine id=cb4-3 title=3>fwrite( &amp;dataVariableToWrite, <span class=kw>sizeof</span>( dataVariable ), <span class=dv>1</span>, filePtr );</a>
<a class=sourceLine id=cb4-4 title=4>fread( &amp;dataVariableToRead, <span class=kw>sizeof</span>( dataVariable ), <span class=dv>1</span>, filePtr );</a>
<a class=sourceLine id=cb4-5 title=5><span class=co>// here 1 is the nr of elements to read; can be something else</span></a></code></pre></div><ul><li>stream: pointer to file<li>offset: (in bytes) file position to seek (relative to the position specified in whence)<li>whence: specifies reference point in file for offset<ul><li><code>SEEK_SET</code>: seek starts at beginning of file<li><code>SEEK_CUR</code>: seek starts at current location in file<li><code>SEEK_END</code>: seek starts at end of file</ul></ul></div><a class=u-url href=C standard library hidden=""></a></article></div></main><footer class="site-footer h-card"><data class=u-url href=/ ></data><div class=wrapper><h2 class=footer-heading>Notes in Progress</h2><div class=footer-col-wrapper><div class="footer-col footer-col-1"><ul class=contact-list><li class=p-name>febkor<li><a class=u-email href=""></a></ul></div></div><div class="footer-col footer-col-3"><p></div></div></footer>