<!DOCTYPE html><html lang=en><head><meta http-equiv=content-type content="text/html; charset=UTF-8"><meta name=viewport content="width=device-width, initial-scale=1"><title>C Standard Library | Notes in Progress</title><meta name=robots content=noindex><meta property=og:title content=C standard library><meta property=og:site_name content=Notes in progress><meta property=og:type content=article><script type=application/ld+json>
  {"@type":"BlogPosting","headline":"Notes in Progress","dateModified":"2019-02-09T00:00:00+00:00","datePublished":"2019-02-09T00:00:00+00:00","url":https://febkor.github.io/NotesInProgress,"mainEntityOfPage":{"@type":"WebPage","@id":https://febkor.github.io/NotesInProgress},"description":"Notes","@context":"http://schema.org"}</script><link rel=stylesheet href=https://febkor.github.io/NotesInProgress/static/main.css><link rel="shortcut icon" type=image/x-icon href=https://febkor.github.io/NotesInProgress/static/favicon.ico><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script></head><body><header class=site-header role=banner><div class=wrapper><a class=site-title rel=author href=https://febkor.github.io/NotesInProgress>Notes in Progress</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger><label for=nav-trigger></label></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><article class="post h-entry" itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class="post-title p-name" itemprop="name headline">C Standard Library</h1></header><div class="post-content e-content" itemprop=articleBody><h1 id=header-files>Header files</h1><ul><li><code>&lt;assert.h&gt;</code>: for adding diagnostics that aid program debugging.</li><li><code>&lt;ctype.h&gt;</code>: for functions that test characters for certain properties, and function prototypes for functions that can be used to convert lowercase letters to uppercase letters and vice versa. <ul><li><code>islower()</code></li><li><code>toupper()</code></li></ul></li><li><code>&lt;errno.h&gt;</code>: for reporting error conditions.</li><li><code>&lt;float.h&gt;</code>: Contains the floating point size limits of the system.</li><li><code>&lt;limits.h&gt;</code>: Contains the integral size limits of the system.</li><li><code>&lt;locale.h&gt;</code>: enables a program to be modified for the current locale. This enables the computer system to handle different conventions for expressing data like dates, times, money and large numbers throughout the world.</li><li><code>&lt;math.h&gt;</code></li><li><code>&lt;setjmp.h&gt;</code>: for functions that allow bypassing of the usual function call and return sequence.</li><li><code>&lt;signal.h&gt;</code>: handle various conditions that may arise during program execution.</li><li><code>&lt;stdarg.h&gt;</code>: for dealing with a list of arguments to a function whose number and types are unknown.</li><li><code>&lt;stddef.h&gt;</code>: Contains common definitions of types used by C for performing certain calculations.</li><li><code>&lt;stdio.h&gt;</code></li><li><code>&lt;stdlib.h&gt;</code>: for conversions of numbers to text and text to numbers, memory allocation, random numbers, and other utility functions.</li><li><code>&lt;string.h&gt;</code>: for string processing functions.</li><li><code>&lt;time.h&gt;</code>: and types for manipulating the time and date.</li></ul><h2 id=dynamic-memory-allocation>Dynamic memory allocation</h2><p>Both the following functions are contained in <code>stdlib.h</code>.</p><ul><li><code>void* malloc(int nrOfBytes)</code><ul><li>allocates memory during execution time</li><li>returns a generic pointer that points to the address of the first memory position in the block</li><li>returns a <code>NULL</code> pointer if it was unable to allocate the memory</li><li>eg <code>type* newptr = malloc (arraySize * sizeof( int ));</code><ul><li>allocates memory for an array of integers</li><li>the array&#x2019;s starting address is stored in <code>newptr</code></li></ul></li></ul></li><li><code>void free(ptrType* pointerToMemory)</code><ul><li>frees memory allocated previously</li><li>always free dynamically allocated memory (prevents memory leaks)</li></ul></li><li>example usage: <ul><li><code>int* myIntAddress = malloc(sizeof(int));</code></li><li><code>free(myIntAddress)</code></li></ul></li><li>you can draw parallels with this and filehandling <ul><li><code>FILE* filePtr = fopen("abc.xyz","r");</code></li><li><code>fclose(filePtr);</code></li></ul></li></ul><p><em>Common errors</em></p><p>Every block of memory allocated with <code>malloc()</code> should eventually be returned to the pool of available memory by exactly one call to <code>free()</code>.</p><ul><li>memory leaks: when a block&#x2019;s address is forgotten but <code>free()</code> is not called for it. The memory it occupies cannot be reused until the program terminates.</li><li>use-after-free: program calls <code>free()</code> for a block and then continues to use the block. This can create a conflict with re-use of the block through another <code>malloc()</code> call.</li><li>double free: when <code>free()</code> is called more than once on a block. Leads to undefined behavior. Can corrupt the state of the memory manager.</li></ul><h2 id=io-library-functions>IO library functions</h2><ul><li><code>printf</code></li><li><code>scanf</code></li><li>printing/reading variables <ul><li><code>%d</code>: decimal integer</li><li><code>%f</code>: float, double (<code>printf</code>)</li><li><code>%e</code>: float, in scientific notation</li><li><code>%lf</code>: double (<code>scanf</code>)</li><li><code>%c</code>: char</li><li><code>%s</code>: string</li><li><code>%4d</code>: field width (left-pads with up to 4 spaces)</li><li><code>%-4d</code>: field width (right-pads with up to 4 spaces)</li><li><code>%.4f</code>: precision (print up to 4 decimal places)</li></ul></li><li>common escape sequences <ul><li><code>\n</code>: Newline. Position the cursor at the beginning of the next line.</li><li><code>\t</code>: Horizontal tab. Move the cursor to the next tab stop.</li><li><code>\a</code>: Alert. Sound the system bell.</li><li><code>\\</code>: Backslash. Insert a backslash character in a string.</li><li><code>\"</code>: Double quote. Insert a double quote character in a string.</li><li><code>\&#x2019;</code>: Single quote. Insert a single quote into string.</li><li><code>\r</code>: Position the cursor at the beginning of the current line.</li><li><code>\?</code>: Insert a question mark character</li><li><code>%%</code>: Percentage symbol</li></ul></li></ul><h2 id=math-library-functions>Math library functions</h2><p>All of the <code>math.h</code> functions return type <code>double</code>.</p><ul><li><code>sqrt(x)</code></li><li><code>exp(x)</code></li><li><code>log(x)</code>: natural logarithm</li><li><code>log10(x)</code></li><li><code>fabs(x)</code>: absolute value of <code>x</code></li><li><code>ceil(x)</code>: rounds <code>x</code> to the smallest integer greater than <code>x</code></li><li><code>floor(x)</code>: rounds <code>x</code> to the largest integer less than <code>x</code></li><li><code>pow(x, y)</code>: <code>x</code> raised to power <code>y</code></li><li><code>fmod(x, y)</code>: remainder of <code>x/y</code> as a floating point number</li><li><code>sin(x)</code>: where <code>x</code> is in radians (all trig functions)</li><li><code>cos(x)</code></li><li><code>tan(x)</code></li></ul><h3 id=generating-random-numbers>Generating random numbers</h3><ul><li>from <code>stdlib.h</code></li><li><code>int rand(void)</code> returns a random integer from <code>0</code> to <code>RAND_MAX = 32767</code></li><li>e.g.&#xA0;<code>i = 2 + rand() % 5;</code> is a pseudorandom number from 2 to 6 (<span class="math inline">= 5+2-1</span>).</li><li>computers generally can&#x2019;t give truly random values; typically a function with an initial value, called a seed, is used to generate numbers that look and behave like random variables (pseudorandm numbers).</li><li><code>rand()</code> generates the same sequence of numbers for the same seed</li><li>can use <code>srand()</code> to change the seed value:</li></ul><div class=sourceCode id=cb1><pre class="sourceCode c"><code class="sourceCode c"><span id=cb1-1><a href=#cb1-1 aria-hidden=true tabindex=-1></a><span class=co>// to set the seed manually</span></span>
<span id=cb1-2><a href=#cb1-2 aria-hidden=true tabindex=-1></a><span class=dt>unsigned</span> <span class=dt>int</span> seed = <span class=dv>42</span>; <span class=co>// unsigned implies non-negative</span></span>
<span id=cb1-3><a href=#cb1-3 aria-hidden=true tabindex=-1></a>srand(seed);</span>
<span id=cb1-4><a href=#cb1-4 aria-hidden=true tabindex=-1></a></span>
<span id=cb1-5><a href=#cb1-5 aria-hidden=true tabindex=-1></a><span class=co>// to set the seed automatically</span></span>
<span id=cb1-6><a href=#cb1-6 aria-hidden=true tabindex=-1></a>srand( time( NULL) ); <span class=co>// need &lt;time.h&gt;</span></span>
<span id=cb1-7><a href=#cb1-7 aria-hidden=true tabindex=-1></a></span>
<span id=cb1-8><a href=#cb1-8 aria-hidden=true tabindex=-1></a><span class=co>// to generate random numbers</span></span>
<span id=cb1-9><a href=#cb1-9 aria-hidden=true tabindex=-1></a>fprintf(<span class=st>&quot;%d&quot;</span>, rand());</span></code></pre></div><h2 id=file-handling>File handling</h2><h3 id=data-files>Data files</h3><ul><li>Can be created, updated, and processed by C programs.</li><li>Are used for permanent storage of large amounts of data. Storage of data in variables and arrays is only temporary.</li><li>Binary files: <ul><li>Unformatted (stored as &#x201C;raw bytes&#x201D;)</li><li>Data not human readable</li><li>Written and read sequentially or randomly</li></ul></li><li>Text files: <ul><li>Data is stored as characters (char)</li><li>Usually only written and read sequentially</li></ul></li></ul><h3 id=opening-and-closing-files>Opening and closing files</h3><p>Opening files</p><div class=sourceCode id=cb2><pre class="sourceCode c"><code class="sourceCode c"><span id=cb2-1><a href=#cb2-1 aria-hidden=true tabindex=-1></a><span class=pp>#include </span><span class=im>&lt;stdio.h&gt;</span></span>
<span id=cb2-2><a href=#cb2-2 aria-hidden=true tabindex=-1></a></span>
<span id=cb2-3><a href=#cb2-3 aria-hidden=true tabindex=-1></a><span class=dt>FILE</span> * filePtr;</span>
<span id=cb2-4><a href=#cb2-4 aria-hidden=true tabindex=-1></a>filePtr = fopen( <span class=st>&quot;someFilename.xyz&quot;</span>, <span class=st>&quot;r&quot;</span> );</span>
<span id=cb2-5><a href=#cb2-5 aria-hidden=true tabindex=-1></a><span class=co>// optional: check if file was opened</span></span>
<span id=cb2-6><a href=#cb2-6 aria-hidden=true tabindex=-1></a><span class=cf>if</span> ( filePtr == NULL ) {</span>
<span id=cb2-7><a href=#cb2-7 aria-hidden=true tabindex=-1></a>    printf( <span class=st>&quot;ERROR - file could not be opened!</span><span class=sc>\n</span><span class=st>&quot;</span> );</span>
<span id=cb2-8><a href=#cb2-8 aria-hidden=true tabindex=-1></a>}</span>
<span id=cb2-9><a href=#cb2-9 aria-hidden=true tabindex=-1></a><span class=cf>else</span>{</span>
<span id=cb2-10><a href=#cb2-10 aria-hidden=true tabindex=-1></a>    <span class=co>// do stuff with the file</span></span>
<span id=cb2-11><a href=#cb2-11 aria-hidden=true tabindex=-1></a>    fclose( filePtr );</span>
<span id=cb2-12><a href=#cb2-12 aria-hidden=true tabindex=-1></a>} </span></code></pre></div><ul><li>Declares pointer <code>filePtr</code> that may point to a file.</li><li>Opens <code>someFilename.xyz</code> and let <code>filePtr</code> points to its beginning.</li><li><code>"r"</code>: File is opened to read and as text file</li><li>Files should always be closed after use</li></ul><p>File open modes</p><ul><li><code>r</code>: Open a file for reading.</li><li><code>w</code>: Create a file for writing. If the file already exists, empty it.</li><li><code>a</code>: Append; open/create a file for writing at end of file.</li><li>update mode: <ul><li><code>r+</code>: Open a file for update (read/write).</li><li><code>w+</code>: Create a file for update (read/write). If the file already exists, empty it.</li><li><code>a+</code>: Append; open/create a file for update; writing is done at the end of the file.</li></ul></li><li>binary mode: <ul><li><code>rb</code>: Open a file for reading in binary mode.</li><li><code>wb</code>: Create a file for writing in binary mode. If the file already exists, empty it.</li><li><code>ab</code>: Append; open/create a file for writing at end of file in binary mode.</li></ul></li><li>update, binary: <ul><li><code>rb+</code>: Open a file for update (read/write) in binary mode.</li><li><code>wb+</code>: Create a file for update in binary mode. If the file already exists, empty it.</li><li><code>ab+</code>: Append; open/create a file for update in binary mode; writing is done at the end of the file</li></ul></li></ul><p>Files and Streams</p><ul><li>C views each file as a sequence of bytes</li><li>File ends with the end-of-file marker or file ends at a specified byte</li><li>Stream created when a file is opened</li><li>A stream is a communication channel between files and programs</li><li>Opening a file returns a pointer to a <code>FILE</code> structure</li><li>Three files with associated streams are automatically opened with program execution: <ul><li>stdin: standard input (keyboard) (in <code>stdio.h</code>)</li><li>stdout: standard output (screen) (in <code>stdio.h</code>)</li><li>stderr: standard error (screen)</li></ul></li><li><code>FILE</code> structure <ul><li>File descriptor <ul><li>Index into an operating system array, the open file table</li></ul></li><li>File Control Block (FCB) <ul><li>Found in every array element, system uses it to administer the file</li></ul></li></ul></li></ul><p>Standard library functions (in <code>stdio.h</code>)</p><ul><li><code>int fgetc( FILE *stream );</code><ul><li>Reads one character from a file</li><li>Takes a <code>FILE</code> pointer as an argument</li><li><code>fgetc( stdin )</code> equivalent to <code>getchar()</code></li></ul></li><li><code>int fputc( int char, FILE *stream );</code></li><li><code>char* fgets( char *str, int count, FILE *stream );</code><ul><li>Reads a line from a file</li></ul></li><li><code>int fputs(const char *str, FILE *stream)</code>;<br></li><li><code>int fscanf( FILE *stream, const char *format, ... );</code><ul><li>File processing equivalents of scanf()</li></ul></li><li><code>int fprintf( FILE *stream, const char *format, ... );</code><ul><li>File processing equivalent of printf()</li></ul></li><li><code>int feof( FILE *stream );</code><ul><li>Returns true if end-of-file indicator (no more data to process) is set for the specified file</li></ul></li><li><code>void rewind( FILE *stream )</code>; <ul><li>Resets the file position pointer to the beginning of the file</li></ul></li></ul><p>Example:</p><div class=sourceCode id=cb3><pre class="sourceCode c"><code class="sourceCode c"><span id=cb3-1><a href=#cb3-1 aria-hidden=true tabindex=-1></a><span class=pp>#include </span><span class=im>&lt;stdio.h&gt;</span></span>
<span id=cb3-2><a href=#cb3-2 aria-hidden=true tabindex=-1></a><span class=pp>#include </span><span class=im>&lt;stdlib.h&gt;</span></span>
<span id=cb3-3><a href=#cb3-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-4><a href=#cb3-4 aria-hidden=true tabindex=-1></a><span class=dt>int</span> main () {</span>
<span id=cb3-5><a href=#cb3-5 aria-hidden=true tabindex=-1></a>   <span class=dt>char</span> str1[<span class=dv>10</span>], str2[<span class=dv>10</span>], str3[<span class=dv>10</span>];</span>
<span id=cb3-6><a href=#cb3-6 aria-hidden=true tabindex=-1></a>   <span class=dt>int</span> year;</span>
<span id=cb3-7><a href=#cb3-7 aria-hidden=true tabindex=-1></a>   <span class=dt>FILE</span> * fp;</span>
<span id=cb3-8><a href=#cb3-8 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-9><a href=#cb3-9 aria-hidden=true tabindex=-1></a>   fp = fopen (<span class=st>&quot;file.txt&quot;</span>, <span class=st>&quot;w+&quot;</span>);</span>
<span id=cb3-10><a href=#cb3-10 aria-hidden=true tabindex=-1></a>   fputs(<span class=st>&quot;We are in 2018&quot;</span>, fp);</span>
<span id=cb3-11><a href=#cb3-11 aria-hidden=true tabindex=-1></a>   </span>
<span id=cb3-12><a href=#cb3-12 aria-hidden=true tabindex=-1></a>   rewind(fp);</span>
<span id=cb3-13><a href=#cb3-13 aria-hidden=true tabindex=-1></a>   fscanf(fp, <span class=st>&quot;%s %s %s %d&quot;</span>, str1, str2, str3, &amp;year);</span>
<span id=cb3-14><a href=#cb3-14 aria-hidden=true tabindex=-1></a>   </span>
<span id=cb3-15><a href=#cb3-15 aria-hidden=true tabindex=-1></a>   <span class=co>// str1 = &quot;We&quot;</span></span>
<span id=cb3-16><a href=#cb3-16 aria-hidden=true tabindex=-1></a>   <span class=co>// str2 = &quot;are&quot;</span></span>
<span id=cb3-17><a href=#cb3-17 aria-hidden=true tabindex=-1></a>   <span class=co>// str3 = &quot;in&quot;</span></span>
<span id=cb3-18><a href=#cb3-18 aria-hidden=true tabindex=-1></a>   <span class=co>// year = &quot;2018&quot;</span></span>
<span id=cb3-19><a href=#cb3-19 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-20><a href=#cb3-20 aria-hidden=true tabindex=-1></a>   fclose(fp);</span>
<span id=cb3-21><a href=#cb3-21 aria-hidden=true tabindex=-1></a>   </span>
<span id=cb3-22><a href=#cb3-22 aria-hidden=true tabindex=-1></a>   <span class=cf>return</span>(<span class=dv>0</span>);</span>
<span id=cb3-23><a href=#cb3-23 aria-hidden=true tabindex=-1></a>}</span></code></pre></div><h3 id=write-toread-from-binary-files>Write to/Read from Binary Files</h3><ul><li><code>fwrite</code>: Transfer bytes from a location in memory to a file</li><li><code>fread</code>: Transfer bytes from a file to a location in memory</li></ul><p>Eg: <code>fwrite( &amp;myObj, sizeof( egType ), 1, fPtr );</code></p><ul><li><code>&amp;myObj</code>: Location to transfer bytes from</li><li><code>sizeof( egType )</code>: Number of bytes to transfer</li><li><code>1</code>: For arrays, number of elements to transfer. In the eg, only one element is being transferred</li><li><code>fPtr</code>: File to transfer to or from</li></ul><h3 id=random-access-files>Random-Access Files</h3><ul><li>Access individual records without searching through other records</li><li>Instant access to records in a file</li><li>Data can be inserted without destroying other data</li><li>Data previously stored can be updated or deleted without overwriting</li><li>Implemented using fixed-length records <ul><li>i.e.&#xA0;some data is set aside for each record</li><li>Text files usually do not have fixed-length records and are therefore handled sequentially (not like the pc can know how long each line will be).</li></ul></li><li>Data in random-access files <ul><li>Random-access files are usually binary/unformatted (stored as &#x201C;raw bytes&#x201D;)</li><li>All data of the same type (eg ints) use the same amount of space as in memory</li><li>All records of the same type have a fixed length</li><li>Data is not human readable</li></ul></li></ul><h3 id=writing-data-to-a-random-access-file>Writing Data to a Random-Access File</h3><p>Sets file position pointer to a specific position</p><div class=sourceCode id=cb4><pre class="sourceCode c"><code class="sourceCode c"><span id=cb4-1><a href=#cb4-1 aria-hidden=true tabindex=-1></a><span class=dt>int</span> fseek( <span class=dt>FILE</span> *stream, <span class=dt>long</span> <span class=dt>int</span> offset, <span class=dt>int</span> whence );</span>
<span id=cb4-2><a href=#cb4-2 aria-hidden=true tabindex=-1></a></span>
<span id=cb4-3><a href=#cb4-3 aria-hidden=true tabindex=-1></a>fwrite( &amp;dataVariableToWrite, <span class=kw>sizeof</span>( dataVariable ), <span class=dv>1</span>, filePtr );</span>
<span id=cb4-4><a href=#cb4-4 aria-hidden=true tabindex=-1></a>fread( &amp;dataVariableToRead, <span class=kw>sizeof</span>( dataVariable ), <span class=dv>1</span>, filePtr );</span>
<span id=cb4-5><a href=#cb4-5 aria-hidden=true tabindex=-1></a><span class=co>// here 1 is the nr of elements to read; can be something else</span></span></code></pre></div><ul><li>stream: pointer to file</li><li>offset: (in bytes) file position to seek (relative to the position specified in whence)</li><li>whence: specifies reference point in file for offset <ul><li><code>SEEK_SET</code>: seek starts at beginning of file</li><li><code>SEEK_CUR</code>: seek starts at current location in file</li><li><code>SEEK_END</code>: seek starts at end of file</li></ul></li></ul></article></div></main><footer class="site-footer h-card"><data href=/ class=u-url></data><div class=wrapper><h2 class=footer-heading>Notes in Progress</h2><div class=footer-col-wrapper><div class="footer-col footer-col-1"><ul class=contact-list><li class=p-name>febkor</li></ul></div></div></div></div></footer></body></html>