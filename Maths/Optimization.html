<!DOCTYPE html><html lang=en><head><meta http-equiv=content-type content="text/html; charset=UTF-8"><meta name=viewport content="width=device-width, initial-scale=1"><title>Optimization | Notes in Progress</title><meta name=robots content=noindex><meta property=og:title content=Optimization><meta property=og:site_name content=Notes in progress><meta property=og:type content=article><script type=application/ld+json>
  {"@type":"BlogPosting","headline":"Notes in Progress","dateModified":"2019-02-09T00:00:00+00:00","datePublished":"2019-02-09T00:00:00+00:00","url":https://febkor.github.io/NotesInProgress,"mainEntityOfPage":{"@type":"WebPage","@id":https://febkor.github.io/NotesInProgress},"description":"Notes","@context":"http://schema.org"}</script><link rel=stylesheet href=https://febkor.github.io/NotesInProgress/static/main.css><link rel="shortcut icon" type=image/x-icon href=https://febkor.github.io/NotesInProgress/static/favicon.ico><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script></head><body><header class=site-header role=banner><div class=wrapper><a class=site-title rel=author href=https://febkor.github.io/NotesInProgress>Notes in Progress</a><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger><label for=nav-trigger></label></nav></div></header><main class=page-content aria-label=Content><div class=wrapper><article class="post h-entry" itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class="post-title p-name" itemprop="name headline">Optimization</h1></header><div class="post-content e-content" itemprop=articleBody><p>In Quasi-Newton methods, the Hessian matrix of second derivatives is not computed. Instead, the Hessian matrix is approximated using updates specified by gradient evaluations.</p><h1 id=unconstrained-nonlinear>Unconstrained nonlinear</h1><ul><li>Nelder-Mead Simplex algorithm <ul><li>derivative-free</li></ul></li><li>Newton-Conjugate-Gradient algorithm <ul><li>use the first-order derivative</li></ul></li><li>Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm <ul><li>use the second-order derivative</li><li>Quasi-Newton method, so approximates the Hessian</li></ul></li><li>Levenberg&#x2013;Marquardt algorithm <ul><li>use the second-order derivative</li><li>also known as the damped least-squares (DLS)</li><li>used to solve non-linear least squares problems</li></ul></li><li>Trust-Region Newton-Conjugate-Gradient Algorithm</li><li>Trust-Region Truncated Generalized Lanczos / Conjugate Gradient Algorithm</li><li>Trust-Region Nearly Exact Algorithm</li></ul><h1 id=constrained-nonlinear>Constrained nonlinear</h1><ul><li>Broyden&#x2013;Fletcher&#x2013;Goldfarb&#x2013;Shanno Bounded (BFGS-B) algorithm <ul><li>iterative method for solving problems with box-constraints</li></ul></li><li>Lagrange Multipliers</li><li>Trust-Region Constrained Algorithm</li><li>Sequential Least SQuares Programming (SLSQP) Algorithm</li><li>Global optimization</li><li>Least-squares minimization</li></ul><h1 id=convex-optimization>Convex optimization</h1><h2 id=linear-programming>Linear programming</h2><p>Linear programming is a technique for the optimization of a linear objective function, subject to linear equality and linear inequality constraints.</p><p>Its feasible region is a convex polytope, which is a set defined as the intersection of finitely many half spaces, each of which is defined by a linear inequality.</p><p>Its objective function is a real-valued affine (linear) function defined on this polyhedron. A linear programming algorithm finds a point in the polytope where this function has the smallest (or largest) value if such a point exists.</p><p>Linear programs are problems that can be expressed in canonical form as</p><p></p><p>where <span class="math inline">x</span> is the unknown vector, and <span class="math inline">A</span> is a known matrix and <span class="math inline">b,c</span> are known vectors.</p><p>Typically solved using the simplex algorithm, or with some variant of the interior-point method.</p><p>The problem can be reformulated to solve variants of the canonical form. For example, to optimize <span class="math inline">c^\mathrm{T} |x|</span>, introduce auxilliary variables <span class="math inline">t_i \geq 0</span> into the constraints so that <span class="math inline">x = t_1 - t_2</span>. The algorithm will set <span class="math inline">t_i</span> such that <span class="math inline">t_1 + t_2 = |x|</span> (one of the <span class="math inline">t_i</span> will be 0).</p><h1 id=references>References</h1><p>https://math.stackexchange.com/questions/432003/converting-absolute-value-program-into-linear-program</p></article></div></main><footer class="site-footer h-card"><data href=/ class=u-url></data><div class=wrapper><h2 class=footer-heading>Notes in Progress</h2><div class=footer-col-wrapper><div class="footer-col footer-col-1"><ul class=contact-list><li class=p-name>febkor</li></ul></div></div></div></div></footer></body></html>